function [transform_params, transforms] = iterative_dce_model_fit_registration...
    (dyn_volumes, tumour_mask, model_signals, varargin)
%TODO: N_voxels vs N_times dimensions need checking 
%ITERATIVE_DCE_MODEL_FIT_REGISTRATION *Insert a one line summary here*
%   [model_params, reg_trans] = iterative_dce_model_fit_registration(dyn_signals, aif, T1, varargin)
%
% Inputs:
%      dyn_signals - *Insert description of input variable here*
%
%      aif - *Insert description of input variable here*
%
%      T1 - *Insert description of input variable here*
%
%      varargin - *Insert description of input variable here*
%
%
% Outputs:
%      model_params - *Insert description of input variable here*
%
%      reg_trans - *Insert description of input variable here*
%
%
% Example:
%
% Notes:
%
% See also:
%
% Created: 21-Aug-2017
% Author: Michael Berks 
% Email : michael.berks@manchester.ac.uk 
% Phone : +44 (0)161 275 7669 
% Copyright: (C) University of Manchester
args = u_packargs(varargin, 0, ...
    'dce_root', [],...
    'num_vols', 75,...
    'apply_smoothing', [],...
    'index_fmt', '%1u',...
    'T1', [],...
    'FA', 20,...
	'TR', 4,...
    'relax_coeff', 4.5e-3,...
    'num_precon', 5,...
    'max_iterations', 16,...
    'model_save_path', [],...
    'debug', 0);
clear varargin;

if isempty(dyn_volumes)
    [dyn_volumes] = get_dyn_vols(...
        [args.dce_root 'dynamic/dyn_'], args.num_vols, args.apply_smoothing, args.index_fmt);
end

if isempty(args.T1)
   args.T1 = load_raw_volume([args.dce_root 'T1.raw']); 
end

if isempty(args.S0)
    args.S0 = load_raw_volume([args.dce_root 'S0.raw']);
end

[n_y, n_x, n_z, n_vols] = size(dyn_volumes);
num_voxels = sum(tumour_mask);

%If model signals are empty we need to compute them - this is slooowww...
if isempty(model_signals)
    %Extract signals at each tumour voxel
    dyn_signals = zeros(num_times, num_voxels);
    for i_t = 1:num_vols
        d = dyn_volumes(:,:,:,i_t);
        dyn_signals(:,i_t) = d(tumour_mask);
    end
    
    T1_tumour = args.T1(tumour_mask);
    S0_tumour = args.S0(tumour_mask);
    
    if isempty(args.dyn_times)
        [args.dyn_times] = get_dyn_times([args.dce_root 'dynamic/dyn_'], 75);
    end
    
    %Fit model to signals
    [model_params.Ktrans, model_params.Ve, model_params.Vp, model_params.offset] = ...
        fit_extended_kety_model(dyn_signals, args.dyn_times, args.aif, T1_tumour, ...
        'S0', S0_tumour,...
        'Ktrans_init', args.Ktrans0,...
        'Vp_init', args.Vp0,...
        'Ve_init', args.Ve0,...
        'offset_init', 0,...
        'debug', 0,...
        'save_path', args.model_save_path);    

    [model_concentrations] = ...
        extended_kety_model(args.dyn_times, args.aif, ...
        model_params.Ktrans, model_params.Vp, model_params.Ve, model_params.offset);
    [model_signals] = ...
        concentration_to_signal(model_concentrations, args.FA, args.TR, T1_tumour, S0_tumour, args.relax_coeff, 0);
end

%Compute the tumour centre
[xi, yi, zi] = meshgrid(...
    (1:n_x),...
    (1:n_y),...
    (1:n_z));
tumour_centre = [mean(xi(tumour_mask)) mean(yi(tumour_mask)) mean(zi(tumour_mask))];

transform_params = zeros(n_vols, 9);
transforms = zeros(4, 4, n_vols);
for i_vol = 1:n_vols
   %Make a model signal volume, this is the target volume in the
   %regsitration
   model_vol = zeros(n_y, n_x, n_z);
   model_vol(tumour_mask) = model_signals(i_vol,:);
   
   [tp tt] = ...
        rigid_registration(dyn_volumes(:,:,:,i_vol), model_vol,...
        'use_pca', false,...
        'init_transform', [],...
        'transform_center', tumour_centre,...
        'preprocessing', [],...
        'cost_function', 'sse',...
        'src_gradients', [],...
        'tgt_gradients', [],...
        'apply_opt_to', 'volume',...
        'roi_mask', tumour_mask,...
        'fov_mask', tumour_mask,...
        'roi_src_threshold', [],...
        'roi_tgt_threshold', [],...
        'debug', args.debug);     
    transform_params(i_vol,:) = tp';
    transforms(:,:,i_vol) = tt;
    
end
    
    
